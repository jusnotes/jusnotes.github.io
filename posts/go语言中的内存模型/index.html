<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Go语言中的内存模型 &middot; Just Notes Slice</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://justnotes.xyzcss/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://justnotes.xyzcss/poole.css">
  <link type="text/css" rel="stylesheet" href="https://justnotes.xyzcss/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://justnotes.xyzcss/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://justnotes.xyz"><h1>Just Notes Slice</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://justnotes.xyz">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Go语言中的内存模型</h1>
  <time datetime=2021-08-20T15:21:17&#43;0800 class="post-date">Fri, Aug 20, 2021</time>
  <h1 id="背景">背景</h1>
<p>高级语言编写的程序都要经过编译之后才会被CPU执行，从高级语言的程序到执行结果往往隐藏了很多不容易被察觉的事情，为了理解内存模型的作用，我们需要先了解程序自编写到运行出结果的几个场景：</p>
<ol>
<li>编译器重排序优化：编译器往往有指令重排序的优化，编译器认为代码可以优化的话，会选择对代码进行优化之后再生成汇编代码，例如程序的源代码是a=3; b=4;，而实际上执行的顺序可能是b=4; a=3；这是因为编译器为了优化执行效率可能对指令进行重排序。</li>
</ol>
<blockquote>
<p>Allows any and all code transformations that do not change the observable behavior of the program. 允许任何不改变程序可观察行为的代码转换。（不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。）</p>
</blockquote>
<ol start="2">
<li>高级编程语言所支持的运算往往不是原子化。为了掩盖不同机器的不同，高级语言往往规定了不同平台上的基础类型具有相同的大小，导致了其所支持的运算往往不是原子化的。（如X64机器上非8字节对齐的64位内存读写往往需要两次内存操作）</li>
<li>CPU流水线的存在导致机器指令的执行顺序也是不一定的。</li>
<li>CPU缓存的存在导致不同CPU上执行的线程观测到同一地址的内存值时不一致的。</li>
</ol>
<p>在单线程情况下，上述操作不会带来任何问题，但是在多线程的情况下，为了保证数据的完整性和一致性，需要满足一下三个特性：</p>
<ol>
<li>原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</li>
<li>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>有序性即不同线程观测到的程序执行的顺序按照代码的先后顺序执行。
为了保证这些特性，比较简单的方式就是去除编译器和处理器的优化技术，但是这样操作会导致较大的性能损失，因此就有了内存模型的概念：</li>
</ol>
<blockquote>
<p>为了保证共享内存的正确性(可见性、有序性、原子性)，内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关，旨在解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证并发场景下的一致性、原子性和有序性。
简单来说内存模型就是语言实现方以及语言使用方双方的一种共识，只有遵循内存模型编写的程序才可以保证程序行为的正确性。</p>
</blockquote>
<h1 id="基本原则-先行发生原则happens-before">基本原则: 先行发生原则（happens before）</h1>
<p>happens-before是一种偏序关系，go程序中，使用先行发生（Happens Before）表示内存操作的偏序。如果事件e1发生在e2前，我们可以说e2发生在e1后（Happens After)。如果不能满足e1发生在e2前或者e1发生在e2后，则e1和e2是并发的。</p>
<h2 id="先行发生事件之间的内存关系">先行发生事件之间的内存关系</h2>
<p>happens-before可以用来确定并发读写之间的可见性关系。对于并发读写问题，我们最关心的经常是reader是否能准确观察到writer写入的值。happens-before正是为这个问题设计的，具体来说，要想让某次读取r准确观察到某次写入w，只需满足：</p>
<ol>
<li>w先行发生于r y       </li>
<li>在w后r前没有对v的其他写操作。（对变量的其他写操作$w'$，要么$w'$先行发生与w，要么r先行发生于$w'$。简单来说就是没有其他的写操作覆盖w操作）
只要满足这两个条件，那我们就一定能读取到正确的值。</li>
</ol>
<h2 id="先行发生的判定">先行发生的判定</h2>
<p>有了happens-before，我们可以确定内存的可见性，借助happens-before的传递性，就可以确定不同事件之间的先后关系，进而只需要了解这些明确的happens-before关系，就能在多线程程序中找到确定性的节点。</p>
<h1 id="go语言中的happens-before关系">Go语言中的happens-before关系</h1>
<ol>
<li>单一goroutine中的自然顺序</li>
</ol>
<blockquote>
<p>在同一个goroutine里，书写在前的代码happens-before书写在后的代码。</p>
</blockquote>
<ol start="2">
<li>初始化
每个go文件都可以有一个init方法，用于执行某些初始化逻辑。当我们开始执行某个main方法时，go会先在一个goroutine里做初始化工作，也就是执行所有go文件的init方法，这个过程中go可能创建多个goroutine并发地执行，因此通常情况下各个init方法是没有happens-before关系的。关于init方法有两条happens-before规则：</li>
<li>a 包导入了 b包，此时b包的init方法happens-before a包的所有代码；</li>
<li>所有init方法happens-before main方法</li>
</ol>
<h2 id="创建goroutine">创建goroutine</h2>
<p><strong><code>go</code>关键字开启新的goroutine，先行发生于这个goroutine开始执行</strong>，例如下面程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {  
    print(<span style="color:#a6e22e">a</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
    <span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>()
}
</code></pre></div><p>调用<code>hello</code>会在之后的某时刻打印出&quot;hello, world&quot;（可能在<code>hello</code>返回之后）</p>
<h2 id="销毁goroutine">销毁goroutine</h2>
<p><strong>gouroutine的退出并不会保证先行发生于程序的任何事件</strong>。例如下面程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello&#34;</span> }()    
    print(<span style="color:#a6e22e">a</span>)
}
</code></pre></div><p>没有用任何同步操作限制对a的赋值，所以并不能保证其他goroutine能看到a的变化。实际上，一个激进的编译器可能会删掉整个go语句。 如果<strong>想要在一个goroutine中看到另一个goroutine的执行效果，请使用锁或者channel这种同步机制来建立程序执行的相对顺序。</strong></p>
<h2 id="channel通信">channel通信</h2>
<p>channel通信是goroutine同步的主要方法。每一个在特定channel的发送操作都会匹配到通常在另一个goroutine执行的接收操作。</p>
<p>在channel的发送操作先行发生于对应的接收操作完成 例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">c</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
    <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>()
    <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>    
    print(<span style="color:#a6e22e">a</span>)
}
</code></pre></div><p>这个程序能保证打印出&quot;hello, world&quot;。对a的写先行发生于在c上的发送，先行发生于在c上的对应的接收完成，先行发生于<code>print</code>。</p>
<p><strong>对channel的关闭先行发生于接收到零值，因为channel已经被关闭了</strong>。</p>
<p>在上面的例子中，将<code>c &lt;- 0</code>替换为<code>close(c)</code>还会产生同样的结果。</p>
<p><strong>无缓冲channel的接收先行发生于发送完成</strong></p>
<p>如下程序（和上面类似，只交换了对channel的读写位置并使用了非缓冲channel）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"> <span style="color:#a6e22e">c</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
    <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>
}
<span style="color:#a6e22e">n</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>()
    <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span>
    print(<span style="color:#a6e22e">a</span>)
}
</code></pre></div><p>此程序也能保证打印出&quot;hello, world&quot;。对a的写先行发生于从c接收，先行发生于向c发送完成，先行发生于<code>print</code>。</p>
<p>如果是带缓冲的channel（例如<code>c = make(chan int, 1)</code>），程序不保证打印出&quot;hello, world&quot;(可能打印空字符，程序崩溃或其他行为)。</p>
<p><strong>在容量为C的channel上的第k个接收先行发生于从这个channel上的第k+C次发送完成</strong>。</p>
<p>这条规则将前面的规则推广到了带缓冲的channel上。可以通过带缓冲的channel来实现计数信号量：channel中的元素数量对应着活动的数量，channel的容量表示同时活动的最大数量，发送元素获取信号量，接收元素释放信号量，这是限制并发的通常用法。</p>
<p>下面程序为<code>work</code>中的每一项开启一个goroutine，但这些goroutine通过有限制的channel来确保最多同时执行三个工作函数（w）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">limit</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">work</span> {   
         <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">w</span> <span style="color:#66d9ef">func</span>()) {
            <span style="color:#a6e22e">limit</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#a6e22e">w</span>()
            <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">limit</span>
        }(<span style="color:#a6e22e">w</span>)
    }
    <span style="color:#66d9ef">select</span>{}
}
</code></pre></div><h2 id="锁">锁</h2>
<p>sync包实现了两个锁的数据类型sync.Mutex和sync.RWMutex。</p>
<p><strong>对任意的sync.Mutex或sync.RWMutex变量l和n &lt; m，n次调用l.Unlock()先行发生于m次l.Lock()返回</strong>
下面程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">l</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
    <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Unlock</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Lock</span>()
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>()
    <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Lock</span>()
    print(<span style="color:#a6e22e">a</span>)
}
</code></pre></div><p>能保证打印出&quot;hello, world&quot;。第一次调用l.Unlock()（在f()中）先行发生于main中的第二次l.Lock()返回, 先行发生于print。</p>
<p><strong>对于sync.RWMutex变量l，任意的函数调用l.RLock满足第n次l.RLock后发生于第n次调用l.Unlock，对应的l.RUnlock先行发生于第n+1次调用l.Lock。</strong></p>
<h2 id="once">Once</h2>
<p>sync包的<code>Once</code>为多个goroutine提供了安全的初始化机制。能在多个线程中执行<code>once.Do(f)</code>，但只有一个<code>f()</code>会执行，其他调用会一直阻塞直到f()返回。
通过<code>执行</code>先行发生（指f()返回）于其他的``返回。
如下程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">once</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setup</span>() {
    <span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doprint</span>() {
    <span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">setup</span>)
    print(<span style="color:#a6e22e">a</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">twoprint</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">doprint</span>()    
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">doprint</span>()
}
</code></pre></div><p>调用<code>twoprint</code>会打印&quot;hello, world&quot;两次。<code>setup</code>只在第一次<code>doprint</code>时执行。</p>
<h1 id="错误的同步方法">错误的同步方法</h1>
<p>注意，读操作r可能会看到并发的写操作w。即使这样也不能表明r后的读能看到w之前的写。
如下程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">1</span>
    <span style="color:#a6e22e">b</span> = <span style="color:#ae81ff">2</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">g</span>() {
    print(<span style="color:#a6e22e">b</span>)    
    print(<span style="color:#a6e22e">a</span>)
}
    
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>()
    <span style="color:#a6e22e">g</span>()
}
</code></pre></div><p><code>g</code>可能先打印出2然后是0。</p>
<p>这个事实证明一些旧的习惯是错误的。
双重检查锁定是为了避免同步的资源消耗。例如twoprint程序可能会错误的写成：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">done</span> <span style="color:#66d9ef">bool</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setup</span>() {
    <span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
    <span style="color:#a6e22e">done</span> = <span style="color:#66d9ef">true</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doprint</span>() {
    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">done</span> {
        <span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">setup</span>)
    }    
    print(<span style="color:#a6e22e">a</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">twoprint</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">doprint</span>()    
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">doprint</span>()
}
</code></pre></div><p>在<code>doprint</code>中看到done被赋值并不保证能看到对a赋值。此程序可能会错误地输出空字符而不是&quot;hello, world&quot;。
另一个错误的习惯是忙等待 例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">done</span> <span style="color:#66d9ef">bool</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setup</span>() {
    <span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
    <span style="color:#a6e22e">done</span> = <span style="color:#66d9ef">true</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">setup</span>()    
    <span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">done</span> {
    }    
    print(<span style="color:#a6e22e">a</span>)
}
</code></pre></div><p>和之前程序类似，在main中看到<code>done</code>被赋值不能保证看到<code>a</code>被赋值，所以此程序也可能打印出空字符。更糟糕的是因为两个线程间没有同步事件，在main中可能永远不会看到<code>done</code>被赋值，所以main中的循环不保证能结束。
对程序做一个微小的改变：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#a6e22e">T</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">msg</span> <span style="color:#66d9ef">string</span>

}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">T</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setup</span>() {
    <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">T</span>)
    <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">msg</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
    <span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">t</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">setup</span>()    
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    }    
    print(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">msg</span>)
}
</code></pre></div><p>即使main看到了<code>g != nil</code>并且退出了循环，也不能保证看到g.msg的初始化值。</p>
<blockquote>
<p>在上面所有的例子中，解决办法都是相同的：明确的使用同步。</p>
</blockquote>

</div>


    </main>

    
      
    
  </body>
</html>
