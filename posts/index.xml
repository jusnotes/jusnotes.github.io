<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Just Notes Slice</title>
    <link>https://justnotes.xyz/posts/</link>
    <description>Recent content in Posts on Just Notes Slice</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 20 Aug 2021 15:21:17 +0800</lastBuildDate><atom:link href="https://justnotes.xyz/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go语言中的内存模型</title>
      <link>https://justnotes.xyz/posts/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 20 Aug 2021 15:21:17 +0800</pubDate>
      
      <guid>https://justnotes.xyz/posts/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>背景 高级语言编写的程序都要经过编译之后才会被CPU执行，从高级语言的程序到执行结果往往隐藏了很多不容易被察觉的事情，为了理解内存模型的作用，我们需要先了解程序自编写到运行出结果的几个场景：
 编译器重排序优化：编译器往往有指令重排序的优化，编译器认为代码可以优化的话，会选择对代码进行优化之后再生成汇编代码，例如程序的源代码是a=3; b=4;，而实际上执行的顺序可能是b=4; a=3；这是因为编译器为了优化执行效率可能对指令进行重排序。   Allows any and all code transformations that do not change the observable behavior of the program. 允许任何不改变程序可观察行为的代码转换。（不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。）
 高级编程语言所支持的运算往往不是原子化。为了掩盖不同机器的不同，高级语言往往规定了不同平台上的基础类型具有相同的大小，导致了其所支持的运算往往不是原子化的。（如X64机器上非8字节对齐的64位内存读写往往需要两次内存操作） CPU流水线的存在导致机器指令的执行顺序也是不一定的。 CPU缓存的存在导致不同CPU上执行的线程观测到同一地址的内存值时不一致的。  在单线程情况下，上述操作不会带来任何问题，但是在多线程的情况下，为了保证数据的完整性和一致性，需要满足一下三个特性：
 原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性即不同线程观测到的程序执行的顺序按照代码的先后顺序执行。 为了保证这些特性，比较简单的方式就是去除编译器和处理器的优化技术，但是这样操作会导致较大的性能损失，因此就有了内存模型的概念：   为了保证共享内存的正确性(可见性、有序性、原子性)，内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关，旨在解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证并发场景下的一致性、原子性和有序性。 简单来说内存模型就是语言实现方以及语言使用方双方的一种共识，只有遵循内存模型编写的程序才可以保证程序行为的正确性。
 基本原则: 先行发生原则（happens before） happens-before是一种偏序关系，go程序中，使用先行发生（Happens Before）表示内存操作的偏序。如果事件e1发生在e2前，我们可以说e2发生在e1后（Happens After)。如果不能满足e1发生在e2前或者e1发生在e2后，则e1和e2是并发的。
先行发生事件之间的内存关系 happens-before可以用来确定并发读写之间的可见性关系。对于并发读写问题，我们最关心的经常是reader是否能准确观察到writer写入的值。happens-before正是为这个问题设计的，具体来说，要想让某次读取r准确观察到某次写入w，只需满足：
 w先行发生于r y  在w后r前没有对v的其他写操作。（对变量的其他写操作$w&#39;$，要么$w&#39;$先行发生与w，要么r先行发生于$w&#39;$。简单来说就是没有其他的写操作覆盖w操作） 只要满足这两个条件，那我们就一定能读取到正确的值。  先行发生的判定 有了happens-before，我们可以确定内存的可见性，借助happens-before的传递性，就可以确定不同事件之间的先后关系，进而只需要了解这些明确的happens-before关系，就能在多线程程序中找到确定性的节点。
Go语言中的happens-before关系  单一goroutine中的自然顺序   在同一个goroutine里，书写在前的代码happens-before书写在后的代码。
 初始化 每个go文件都可以有一个init方法，用于执行某些初始化逻辑。当我们开始执行某个main方法时，go会先在一个goroutine里做初始化工作，也就是执行所有go文件的init方法，这个过程中go可能创建多个goroutine并发地执行，因此通常情况下各个init方法是没有happens-before关系的。关于init方法有两条happens-before规则： a 包导入了 b包，此时b包的init方法happens-before a包的所有代码； 所有init方法happens-before main方法  创建goroutine go关键字开启新的goroutine，先行发生于这个goroutine开始执行，例如下面程序：</description>
    </item>
    
  </channel>
</rss>
